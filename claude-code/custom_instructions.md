# Custom Instructions for Claude Code

프로젝트별로 커스터마이징할 수 있는 지침 템플릿입니다.

## Project Context Template

```markdown
# Project: [PROJECT_NAME]

## Overview
[Briefly describe what this project does]

## Tech Stack
- Language: [e.g., Python 3.11, TypeScript 5.0]
- Framework: [e.g., FastAPI, React, Django]
- Database: [e.g., PostgreSQL, MongoDB]
- Key Libraries: [List important dependencies]

## Code Style Guidelines

### Naming Conventions
- Variables: [e.g., snake_case, camelCase]
- Functions: [e.g., snake_case, camelCase]
- Classes: [e.g., PascalCase]
- Constants: [e.g., UPPER_SNAKE_CASE]

### Code Organization
- [Describe your project structure]
- [Module/package naming conventions]
- [Import ordering preferences]

### Best Practices
- [Any specific patterns or practices your team follows]
- [Error handling approach]
- [Logging conventions]

## Testing Requirements
- Test framework: [e.g., pytest, Jest]
- Minimum coverage: [e.g., 80%]
- Test file naming: [e.g., test_*.py, *.test.ts]

## Documentation Standards
- [Docstring format: e.g., Google style, NumPy style]
- [Comment guidelines]
- [README requirements]

## Specific Instructions for Claude
When writing code for this project:
1. [Custom instruction 1]
2. [Custom instruction 2]
3. [Custom instruction 3]
```

## Example: Python FastAPI Project

```markdown
# Project: TaskManager API

## Overview
A RESTful API for task management built with FastAPI and PostgreSQL.

## Tech Stack
- Language: Python 3.11
- Framework: FastAPI 0.104.0
- Database: PostgreSQL 15
- ORM: SQLAlchemy 2.0
- Key Libraries: Pydantic, Alembic, pytest

## Code Style Guidelines

### Naming Conventions
- Variables & Functions: snake_case
- Classes: PascalCase
- Constants: UPPER_SNAKE_CASE
- Private methods: _leading_underscore

### Code Organization
- `/app` - Main application code
  - `/api` - API routes
  - `/models` - SQLAlchemy models
  - `/schemas` - Pydantic schemas
  - `/services` - Business logic
  - `/core` - Configuration and utilities
- `/tests` - Test files mirroring app structure
- `/alembic` - Database migrations

### Best Practices
- Use Pydantic models for request/response validation
- Implement dependency injection for database sessions
- All database operations in service layer, not routes
- Use async/await for I/O operations
- Comprehensive error handling with custom exceptions
- Structured logging with context

## Testing Requirements
- Test framework: pytest with pytest-asyncio
- Minimum coverage: 80%
- Test file naming: test_*.py
- Use fixtures for test data and database setup
- Mock external API calls

## Documentation Standards
- Google-style docstrings for all public functions and classes
- OpenAPI documentation auto-generated by FastAPI
- Keep README updated with setup and deployment instructions

## Specific Instructions for Claude
When writing code for this project:
1. Always use type hints for function parameters and return values
2. Create Pydantic schemas for all API inputs/outputs
3. Use SQLAlchemy 2.0 style (not legacy)
4. Implement proper error handling with HTTPException
5. Write unit tests for all service layer functions
6. Use environment variables for configuration (never hardcode)
7. Follow RESTful API naming conventions
8. Add logging for important operations
```

## Example: React TypeScript Project

```markdown
# Project: TaskManager Frontend

## Overview
A modern task management web application built with React and TypeScript.

## Tech Stack
- Language: TypeScript 5.2
- Framework: React 18.2
- State Management: Zustand
- Styling: Tailwind CSS
- Build Tool: Vite
- Key Libraries: React Query, React Router, Axios

## Code Style Guidelines

### Naming Conventions
- Components: PascalCase (e.g., TaskList.tsx)
- Hooks: camelCase with 'use' prefix (e.g., useTaskStore.ts)
- Utilities: camelCase
- Constants: UPPER_SNAKE_CASE
- Types/Interfaces: PascalCase

### Code Organization
- `/src/components` - React components
  - `/common` - Reusable components
  - `/features` - Feature-specific components
- `/src/hooks` - Custom React hooks
- `/src/store` - Zustand stores
- `/src/services` - API calls
- `/src/types` - TypeScript type definitions
- `/src/utils` - Utility functions

### Best Practices
- Functional components with hooks (no class components)
- Custom hooks for reusable logic
- Prop types defined with TypeScript interfaces
- Use React Query for server state management
- Zustand for client state management
- Tailwind for styling (avoid inline styles)
- Component composition over prop drilling

## Testing Requirements
- Test framework: Vitest + React Testing Library
- Minimum coverage: 70%
- Test file naming: *.test.tsx
- Focus on user behavior, not implementation details

## Documentation Standards
- JSDoc comments for complex functions
- Prop interfaces documented with comments
- README with setup and component documentation

## Specific Instructions for Claude
When writing code for this project:
1. Always use TypeScript (never 'any' type without good reason)
2. Prefer functional components with hooks
3. Use React Query for data fetching
4. Implement proper error boundaries
5. Make components responsive with Tailwind
6. Extract reusable logic into custom hooks
7. Use proper semantic HTML
8. Implement accessibility features (ARIA labels, keyboard navigation)
9. Optimize re-renders with useMemo/useCallback when needed
10. Write tests focusing on user interactions
```

## How to Use

1. Copy the template that matches your project type
2. Fill in your project-specific details
3. Add this to your project documentation or `.claude` file
4. Reference it when starting conversations with Claude about your code

## Tips for Effective Instructions

- **Be Specific**: Vague instructions lead to inconsistent results
- **Include Examples**: Show what you want, not just describe it
- **Update Regularly**: Keep instructions current as your project evolves
- **Prioritize**: List most important guidelines first
- **Be Consistent**: Use the same terminology throughout your project
